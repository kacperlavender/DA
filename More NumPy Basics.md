#### Psuedorandom Number Generation

The numpy.random module supplements the built-in Python random module with functions for efficiently generating whole arrays of sample values from many kinds of probability distributions. For example, you can get a 4 × 4 array of samples from the standard normal distribution using numpy.random.standard_normal:
```python
In [141]: samples = np.random.standard_normal(size=(4, 4))

In [142]: samples
Out[142]:
array([[-0.43889956, -0.09747456,  0.39861605, -0.14493201],
       [-1.1164381 ,  0.82711204,  0.20798732,  2.2103972 ],
       [-1.92834861,  0.46986712, -0.00372926,  1.15921719],
       [-0.00678989, -1.38173213,  0.4651292 ,  0.4698567 ]])
```
Python’s built-in random module, by contrast, samples only one value at a time. As
you can see from this benchmark, numpy.random is well over an order of magnitude
faster for generating very large samples.

These random numbers are not truly random (rather, pseudorandom) but instead are generated by a configurable random number generator that determines deterministically what values are created.


| Method            | Description                                                                  |
| ----------------- | ---------------------------------------------------------------------------- |
| `permutation`     | Return a random permutation of a sequence, or return a permuted range        |
| `shuffle`         | Randomly permute a sequence in place                                         |
| `uniform`         | Draw samples from a uniform distribution                                     |
| `integers`        | Draw random integers from a given low-to-high range                          |
| `standard_normal` | Draw samples from a normal distribution with mean 0 and standard deviation 1 |
| `binomial`        | Draw samples from a binomial distribution                                    |
| `normal`          | Draw samples from a normal (Gaussian) distribution                           |
| `beta`            | Draw samples from a beta distribution                                        |
| `chisquare`       | Draw samples from a chi-square distribution                                  |
| `gamma`           | Draw samples from a gamma distribution                                       |
| `uniform`         | Draw samples from a uniform [0, 1) distribution                              |


### Universal Funcions: Fast Element-Wise Array Functions 

| Function                                                      | Description                                                                                                 |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| `abs`, `fabs`                                                 | Compute the absolute value element-wise for integer, floating-point, or complex values                      |
| `sqrt`                                                        | Compute the square root of each element (equivalent to `arr ** 0.5`)                                        |
| `square`                                                      | Compute the square of each element (equivalent to `arr ** 2`)                                               |
| `exp`                                                         | Compute the exponent \(e^x\) of each element                                                                |
| `log`, `log10`, `log2`, `log1p`                               | Natural logarithm (base e), log base 10, log base 2, and log(1 + x), respectively                           |
| `sign`                                                        | Compute the sign of each element: 1 (positive), 0 (zero), or –1 (negative)                                  |
| `ceil`                                                        | Compute the ceiling of each element (i.e., the smallest integer greater than or equal to that number)       |
| `floor`                                                       | Compute the floor of each element (i.e., the largest integer less than or equal to each element)            |
| `rint`                                                        | Round elements to the nearest integer, preserving the dtype                                                 |
| `modf`                                                        | Return fractional and integral parts of array as separate arrays                                            |
| `isnan`                                                       | Return Boolean array indicating whether each value is NaN (Not a Number)                                    |
| `isfinite`, `isinf`                                           | Return Boolean array indicating whether each element is finite (non-inf, non-NaN) or infinite, respectively |
| `cos`, `cosh`, `sin`, `sinh`, `tan`, `tanh`                   | Regular and hyperbolic trigonometric functions                                                              |
| `arccos`, `arccosh`, `arcsin`, `arcsinh`, `arctan`, `arctanh` | Inverse trigonometric functions                                                                             |
| `logical_not`                                                 | Compute truth value of `not x` element-wise (equivalent to `~arr`)                                          |

| Function                                                               | Description                                                                                                                |
| ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| `add`                                                                  | Add corresponding elements in arrays                                                                                       |
| `subtract`                                                             | Subtract elements in the second array from the first array                                                                 |
| `multiply`                                                             | Multiply array elements                                                                                                    |
| `divide`, `floor_divide`                                               | Divide or floor divide (truncating the remainder)                                                                          |
| `power`                                                                | Raise elements in the first array to powers indicated in the second array                                                  |
| `maximum`, `fmax`                                                      | Element-wise maximum; `fmax` ignores NaN                                                                                   |
| `minimum`, `fmin`                                                      | Element-wise minimum; `fmin` ignores NaN                                                                                   |
| `mod`                                                                  | Element-wise modulus (remainder of division)                                                                               |
| `copysign`                                                             | Copy the sign of values in the second argument to values in the first argument                                             |
| `greater`, `greater_equal`, `less`, `less_equal`, `equal`, `not_equal` | Perform element-wise comparison, yielding a Boolean array (equivalent to infix operators `>`, `>=`, `<`, `<=`, `==`, `!=`) |
| `logical_and`                                                          | Compute element-wise truth value of AND (`&`) logical operation                                                            |
| `logical_or`                                                           | Compute element-wise truth value of OR (`\|`)                                                                              |
| `logical_xor`                                                          | Compute element-wise truth value of XOR (`^`) logical operation                                                            |

### Expressing Conditional Logic as Array Operations
The numpy.where function is a vectorized version of the ternary expression x if condition else y. Suppose we had a Boolean array and two arrays of values:
```python
In [180]: xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])

In [181]: yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])

In [182]: cond = np.array([True, False, True, True, False])
```

Suppose we wanted to take a value from xarr whenever the corresponding value in cond is True, and otherwise take the value from yarr. A list comprehension doing this might look like:
```python
In [183]: result = [(x if c else y)
.....: for x, y, c in zip(xarr, yarr, cond)]

In [184]: result
Out[184]: [1.1, 2.2, 1.3, 1.4, 2.5]
```
This has multiple problems. First, it will not be very fast for large arrays (because all the work is being done in interpreted Python code). Second, it will not work with multidimensional arrays. With numpy.where you can do this with a single function call:
```python
In [185]: result = np.where(cond, xarr, yarr)

In [186]: result
Out[186]: array([1.1, 2.2, 1.3, 1.4, 2.5])
```



A typical use of where in data analysis is to produce a new array of values based on another array. Suppose you had a matrix of randomly generated data and you wanted to replace all positive values with 2 and all negative values with -2. This is possible to do with numpy.where:
```python
In [187]: arr = rng.standard_normal((4, 4))

In [188]: arr
Out[188]:
array([[ 0.13595685,  1.34707776,  0.06114402,  0.0709146 ],
       [ 0.43365454,  0.27748366,  0.53025239,  0.53672097],
       [ 0.61835001, -0.79501746,  0.30003095, -1.60270159],
       [ 0.26679883, -1.26162378, -0.07127081,  0.47404973]])
In [189]: arr > 0
Out[189]:
array([[ True,  True,  True,  True],
       [ True,  True,  True,  True],
       [ True, False,  True, False],
       [ True, False, False,  True]])
       
In [190]: np.where(arr > 0, 2, -2)
Out[190]:
array([[ 2,  2,  2,  2],
       [ 2,  2,  2,  2],
       [ 2, -2,  2, -2],
       [ 2, -2, -2,  2]])
```


#### Mathematical and Statistical Model
A set of mathematical functions that compute statistics about an entire array or about the data along an axis are accessible as methods of the array class. You can use aggregations (sometimes called reductions) like sum, mean, and std (standard deviation) either by calling the array instance method or using the top-level NumPy function. For example:
```python
In [192]: arr = rng.standard_normal((5, 4))

In [193]: arr
Out[193]:
array([[-0.41485376,  0.0977165 , -1.64041784, -0.85725882],
       [ 0.68828179, -1.15452958,  0.65045239, -1.38835995],
       [-0.90738246, -1.09542531,  0.00714569,  0.5343599 ],
       [-1.06580785, -0.18147274,  1.6219518 , -0.31739195],
       [-0.81581497,  0.38657902, -0.22363893, -0.70169081]])
       
In [194]: arr.mean()
Out[194]: -0.08719744457434529 # OR

In [195]: np.mean(arr)
Out[195]: -0.08719744457434529

In [196]: arr.sum()
Out[196]: -1.743948891486906
```


#### Sum of Axis
arr.mean(axis=1) means “compute mean across the columns,” where arr.sum(axis=0) means “compute sum down the rows.”



Basic array statistical methods

| Method             | Description                                                                          |
| ------------------ | ------------------------------------------------------------------------------------ |
| `sum`              | Sum of all the elements in the array or along an axis; zero-length arrays have sum 0 |
| `mean`             | Arithmetic mean; invalid (returns NaN) on zero-length arrays                         |
| `std`, `var`       | Standard deviation and variance, respectively                                        |
| `min`, `max`       | Minimum and maximum                                                                  |
| `argmin`, `argmax` | Indices of minimum and maximum elements, respectively                                |
| `cumsum`           | Cumulative sum of elements starting from 0                                           |
| `cumprod`          | Cumulative product of elements starting from 1                                       |


#### Array set operations

| **Method**            | **Description**                                                                 |
|-----------------------|-------------------------------------------------------------------------------|
| `unique(x)`          | Compute the sorted, unique elements in `x`                                    |
| `intersect1d(x, y)`  | Compute the sorted, common elements in `x` and `y`                           |
| `union1d(x, y)`      | Compute the sorted union of elements                                         |
| `in1d(x, y)`        | Compute a Boolean array indicating whether each element of `x` is in `y`     |
| `setdiff1d(x, y)`   | Set difference, elements in `x` that are not in `y`                          |
| `setxor1d(x, y)`    | Set symmetric differences; elements that are in either `x` or `y`, but not both |

#### Linear algebra
| Function | Description |
|----------|-------------|
| **diag** | Return the diagonal (or off-diagonal) elements of a square matrix as a 1D array, or convert a 1D array into a square matrix with zeros on the off-diagonal. |
| **dot**  | Matrix multiplication. |
| **trace** | Compute the sum of the diagonal elements. |
| **det**  | Compute the matrix determinant. |
| **eig**  | Compute the eigenvalues and eigenvectors of a square matrix. |
| **inv**  | Compute the inverse of a square matrix. |
| **pinv** | Compute the Moore-Penrose pseudoinverse of a matrix. |
| **qr**   | Compute the QR decomposition. |
| **svd**  | Compute the singular value decomposition (SVD). |
| **solve**| Solve the linear system Ax = b for x, where A is a square matrix. |
| **lstsq**| Compute the least-squares solution to Ax = b. |

### Random walks
```
import matplotlib.pyplot as plt

position = 0 
walk = [position]
nsteps = 1000
for _ in range(nsteps):
    step = 1  if random.randint(0,1) else -1
    position += step
    walk.append(position)
    
In [255]: plt.plot(walk[:100])
```

![[Pasted image 20250130002343.png]]
